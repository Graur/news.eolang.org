---
layout: post
date: 2022-07-18
title: "The new semantic of 'try' object"
author: Graur
---

The object `try` enables catching of an `error` objects and extracting exceptions from them.
For example, the following code prints "The 1th argument of 'int.div' is invalid: division by zero is infinity" and then "finally":

```
QQ.try
  []
    42.div 0 > @
  [e]
    QQ.io.stdout > @
      e
  []
    QQ.io.stdout > @
      "finally"
```

Here, the object `error` encapsulates error message from `int.div` object and terminates the program.
But our new "try/catch/finally" structure allows us to catch and use it however we want.

We can also floating up this error like this:

```
  eq. > @
    QQ.try
      []
        QQ.try > @
          []
            slice. > @
              "some string"
              7
              5
          [e]
            e > @
          []
            "first finally block" > @
      [e]
        e > @
      []
        "second finally block" > @
    "Start index + length must not exceed string length but was 12 > 11"
```

Here, we get `TRUE` because `string.slice` object uses `error` object. 
Which encapsulates error message "Start index + length must not exceed string length but was 12 > 11". 
The first `try` object throwing up this encapsulated string to the second `try` object.

<!--more-->

We can add new behavior to caught errors, or just use them as is.
For example, the following code prints "division by zero is infinity, please check the parameter"

```
QQ.try
  []
    3.div 0 > @
  [e]
    QQ.io.stdout > @
      QQ.txt.sprintf
        e.slice 43 28
  []
    QQ.io.stdout > @
      ", please check the parameter"
```

Visit our [paper](https://arxiv.org/abs/2206.02585) to get more details.
